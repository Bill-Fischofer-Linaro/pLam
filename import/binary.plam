-------------------------------------------
--            BINARY LIBRARY             --
--=======================================--

-- TODO wishes:
---- features   : negative numerals
---- operations : div, mod
---- fixes      : mul, mulb simplify, sub a b (a<b), sub L, carry


---------------- BOOLEANS -----------------
T = \x y. x
F = \x y. y
not = \x. x F T
and = \x y. x y F
or = \x y. x T y
or3 = \x y z. or (or x y) z
xor = \x y. x (not y) y
xor3 = \x y z. xor (xor x y) z
-------------------------------------------

-- pair operations
pair = \x y p. p x y
fst = \p. p T
snd = \p. p F

-- this represents the end of the list
end = \e. T
isEnd = \e. e (\x y. F)
-- this represents that numeral should be zero
numZ = \x y. T
isNumZ = \z. z F F

-- Y combinator
Y = \f. (\x. f(x x)) (\x. f(x x))


--------------------
--    ADDITION    --
--================--
carryA = \x y c. or (and x y) (and (or x y) c)

-- equal size addition
addB0e = Y (\f. \x y c. (isEnd x) (c (pair T end) end) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryA (fst x) (fst y) c))))
addBe = \x y. addB0e x y F

-- variant size addition
forkA = \x y c. (and (isEnd x) (isEnd y)) (c (pair T end) end) ((isEnd x) (pair (xor3 F (fst y) c) (f end (snd y) (carryA F (fst y) c))) ((isEnd y) (pair (xor3 (fst x) F c) (f (snd x) end (carryA (fst x) F c))) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryA (fst x) (fst y) c)))))

-- E = c (pair T end) end
-- M = pair (xor3 F (fst y) c) (f end (snd y) (carryA F (fst y) c))
-- N = pair (xor3 (fst x) F c) (f (snd x) end (carryA (fst x) F c))
-- L = pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryA (fst x) (fst y) c))

addB0 = Y (\f. forkA)
addB = \x y. addB0 x y F
-------------------------------------------------

------------------------
--    SUBSTRACTION    --
--====================--
carryS = \x y c. or (and (not x) y) (and (not (or x y)) c)

-- equal size substraction
subB0e = Y (\f. \x y c. (isEnd x) end (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryS (fst x) (fst y) c))))
subBe = \x y. subB0e x y F

-- variant substraction
forkS = \x y c. (and (isEnd x) (isEnd y)) (c (pair numZ end) end) ((isEnd x) (pair numZ end) ((isEnd y) (pair (xor3 (fst x) F c) (f (snd x) end (carryS (fst x) F c))) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryS (fst x) (fst y) c)))))

-- E1 = end
-- E2 = end
-- B = pair (xor3 (fst x) F c) (f (snd x) end (carryS (fst x) F c))
-- D = pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carryS (fst x) (fst y) c))

-- whether a binary numeral has numZ bit
hasZ = Y (\f. \x. (isEnd x) F ((isNumZ (fst x)) T (f (snd x))))
makeZ = \x. (hasZ x) :b0 x

subB0 = Y (\f. forkS)
subB = \x y. subB0 x y F
subsB = \x y. makeZ (subB0 x y F)
----------------------------------------------

--------------------
--    ADEQUACY    --
--================--
-- test for zero
isZeroB = Y (\f. \x. (isEnd x) T ((fst x) F (f (snd x))))

-- successor
SB = \x. addB x :b1

-- predecessor
PB = \x. subB x :b1
---------------------------------------------

-- multiplication
mulb = Y (\f. \x b. (isEnd x) end (b (pair (fst x) (f (snd x) b)) (pair F (f (snd x) b))))
shiftr = \x. pair F x
mulB0 = Y (\f. \x y s. (isEnd y) s (f x (snd y) (addB s (shiftr (mulb x (fst y))))))
mulB = \x y. mulB0 x y :b0

-- primitive recursion, version 0
--PR0 = \G H. (Y (\f k. (isZeroB k) G (H k (f (PB k)))))


