-------------------------------------------
--            BINARY LIBRARY             --
--=======================================--

-- TODO: negative numerals

---------------- BOOLEANS -----------------
T = \x y. x
F = \x y. y
not = \x. x F T
and = \x y. x y F
or = \x y. x T y
or3 = \x y z. or (or x y) z
xor = \x y. x (not y) y
xor3 = \x y z. xor (xor x y) z
-------------------------------------------

pair = \x y p. p x y
fst = \p. p T
snd = \p. p F

-- this represents the end of the list
end = \e. T
isEnd = \p. p (\x y. F)


--========== TESTING ==========--
-- constructor for 4-bit numerals
make4b = \x y z w. pair x (pair y (pair z (pair w end)))

-- 4-bit numerals for testing
B0 = make4b F F F F
B1 = make4b T F F F
B2 = make4b F T F F
B3 = make4b T T F F
B4 = make4b F F T F
B5 = make4b T F T F
B6 = make4b F T T F
B7 = make4b T T T F

-- 6-bit numerals for testing
make6b = \a b c d e f. pair a (pair b (pair c (pair d (pair e (pair f end)))))

B53 = make6b T F T F T T
B12 = make6b F F T T F F

-- 8-bit numerals for testing
make8b = \a b c d e f g h. pair a (pair b (pair c (pair d (pair e (pair f (pair g (pair h end)))))))

B85 = make8b T F T F T F T F
B204 = make8b F F T T F F T T
--=============================--


-- Y combinator
Y = \f. (\x. f(x x)) (\x. f(x x))

-- constant size addition
carrya = \x y c. or (and x y) (and (or x y) c)
addB0 = Y (\f. \x y c. (isEnd x) (c (pair T end) end) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carrya (fst x) (fst y) c))))
addB = \x y. addB0 x y F

-- variant size addition
forka = \x y c A B C. (and (isEnd x) (isEnd y)) (c (pair T end) end) ((isEnd x) A ((isEnd y) B C))

-- A = pair (xor3 F (fst y) c) (f end (snd y) (carrya F (fst y) c))
-- B = pair (xor3 (fst x) F c) (f (snd x) end (carrya (fst x) F c))
-- C = pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carrya (fst x) (fst y) c))

addB0v = Y (\f. \x y c. forka x y c (pair (xor3 F (fst y) c) (f end (snd y) (carrya F (fst y) c))) (pair (xor3 (fst x) F c) (f (snd x) end (carrya (fst x) F c))) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carrya (fst x) (fst y) c))))
addBv = \x y. addB0v x y F

-- substraction
carrys = \x y c. or (and (not x) y) (and (not (or x y)) c)
subB0 = Y (\f. \x y c. (isEnd x) end (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carrys (fst x) (fst y) c))))
subB = \x y. subB0 x y F

-- variant substraction
forks = \x y A B C. (and (isEnd x) (isEnd y)) end ((isEnd x) A ((isEnd y) B C))
subB0v = Y (\f. \x y c. forks x y (pair (xor3 F (fst y) c) (f end (snd y) (carrys F (fst y) c))) (pair (xor3 (fst x) F c) (f (snd x) end (carrys (fst x) F c))) (pair (xor3 (fst x) (fst y) c) (f (snd x) (snd y) (carrys (fst x) (fst y) c))))
subBv = \x y. subB0v x y F


-- successor
SB = \x. addBv x (pair T end)

-- predecessor
PB = \x. subBv x (pair T end)


-- multiplication
mulb = Y (\f. \x b. (isEnd x) end (pair (and (fst x) b) (f (snd x) b)))
shiftr = \x. pair F x
mulB0 = Y (\f. \x y s. (isEnd y) s (f x (snd y) (shiftr (addBv s (mulb x (fst y))))))
mulB = \x y. mulB0 x y :b0




